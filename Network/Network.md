구조가 3가지 중에 무엇인지 따져보는 습관



### 세 가지 네트워크 장치 구조



Inline은 공기 청정기 생각하기

=> 대표적인 장치가 "라우터"



Out of Path는 다루는 데이터 단위는 같으나, 차단/허용의 개념이 아니라, "인지"(즉 읽기) 가 주 목적

=> 보안상 이슈를 "인지" 하면 보안센서이다.

=> 네트워크 장애를 "인지"하면 장애센서 이다.



따라서, 네트워크 센서라고 하면 거의 Out Of path 구조이다.

** Tab 스위치를 통해서, 패킷을 복사받고 분석해서 센서가 결과를 알려줌.



Proxy는 데이터 단위가 "스트림 수준" => 스트림 데이터를 볼 수 있다는 장점이 있다.

(예) 10MB 파일을 보려면(=패킷에서 스트림을 얻으려면), 거의 10000개의 패킷을 조립해야 한다. 이는 굉장히 어려운 일이다.)

=> 따라서, 파일 수준의 데이터 단위를 다룰 떄, Proxy 구조를 다룬다.

=> 구조 자체는 Inline과 비슷(Drop/Bypass 기능이 있다.)

=> But, ReadOnly는 존재하지 않는다. 

(대리자를 통해서 지나가는 개념이라, 어플리케이션 전체를 모니터링 한다. )



 (노트 그림 보기)



### Inline 구조

-Inline 구조

고속도로(네트워크)에서 자동차(패킷)이 움직일 때는, 톨게이트를 반드시 통과해야 한다.



inline구조의 예) 공유기, 라우터, 방화벽(패킷 필터링 방화벽), IPS 등



=> 이처럼, 어느 한 컴퓨터에서 다른 서버로 접속할 때, 여러 Inline 장치를 거쳐서 도달하게 된다.





라우터도 "랜카드가 여러 개 달린" 컴퓨터라고 생각하면 되게 쉽다!



<라우터의 구조>

택배기사가 물건을 받았다고, 소유권이 택배기사에 있는 것이 아니듯이, 라우터는 "남의 데이터"를 받아서 byPass나 drop을 결정한다.



=> 구현은 커널모드에서 이루어진다(당연히, 입출력속도가 커널모드가 user Mode보다 훨씬 빠르기 때문이다.)



(그림 참조)

가속 NIC은, 커널모드에서 이루어지는 작업(IP 패킷 분해 등)을 하드웨어 수준에서 처리한다

=> 이는, 순전히 속도 문제 때문이다.

=> 따라서, Inline Device는 "Throughput"이라는 용어까지 있을 정도이다. 

(예를 들어 네트워크가 10Gbps 급이라도, 중간에 Router 하나가 1Gbps 급이라면 전체 네트워크 성능은 하향평준화가 될 수 밖에 없다.)

=> 그래서, 하드웨어 수준에서 들어오고 나가고를 바로 하는 것이 가장 이상적

=> 따라서, 하드웨어와 inline module(즉, s/w)의 기능의 절충안을 찾는 것이 가장 일반적.



=> 이제 정리하면, Inline Device는 들어온 패킷을 Drop하거나 pass 시킬 수 있다. 어떤 로직으로 이러한 것을 결정하는 가에 따라, Inline Device의 성격이 완전히 바뀐다.





** 여담으로, Router역시 컴퓨터이다. 따라서, 아래의 경우도 가능하다

* Router에 windows 운영체제 설치

* 내 컴퓨터에 Router에서 사용하는 OS 설치

  => 이 경우, 내 컴퓨터는 Router 역할을 한다

=> 따라서, Cisco는 단순히 H/W 회사 뿐만 아니라, Inline Device기능을 하도록 S/W 모듈과 자체 OS까지 같이 만드는 회사라고 볼 수 있다.



### Out of path 구조와 DPI 그리고 망중립

Out of Path의 또다른 이름은 "Sensor" 이다.

=> Sensing할 네트워크 장비가 있어야 한다.

=> "L2 수준에서의 Port Mirroring"이다. (즉,  패킷이 유통될 때, 복사해서 보자라는 의미이다.)

=> 즉, 스위치가 스위칭하는 모든 L2 Frame을 어느 특정 다른 port로 copy한다는 의미이다.

 



Mirroring은 부하가 많이 걸리므로, 하드웨어 적으로 우수해야 한다.

=> 스위치 중, "Tab switch" 라고 있음 (Mirroring만 전문적으로 함)

=> 해당 스위치의 port가 10개라면, 8개의 포트가 mirroring 역할을 수행한다. (2개 포트를 통해 switch를 통과하는 패킷을 대략 8곳에 복사하는 역할을 한다. )

=> 따라서, 부하가 많이 걸리므로, 고성능이다.

=> 이렇게 많이 복사하는 이유는, 2개는 보안에 쓰고, 2개는 장애 대응에 쓰고..... 등이다.



Out of path의 목적은, "분석" 혹은 "탐지"의 목적이다.

=> 따라서, Sensor는, "수집 장치"라는 단어와 항상 따라다닌다.



#### 반사회적 사이트 접속 차단 원리

* www.abc.com 입력 시, warning 페이지가 뜨게 하려면 아래와 같다 (대략적인 설명)

  1. ISP 수준에서 패킷을 수집한다.
  2. Sensor(Out of Path 구조 Device)가 해당 사이트가 접속하면 안 되는 사이트임을 인지
  3. 위의 Device가 거짓응답을 클라이언트에게 보내서, www.abc.com의 응답결과로 warning 페이지가 보이게끔 한다.

  

  

* 아래의 용어를 알아야 한다.

  * L7 HTTP 수준에서 알아야 할 용어

    * TCP/IP 헤더 이외에 HTTP 헤더를 들여다 보는 행위 => SPI 라고 한다. (Shallow packet Inspection)

    * 그리고 data 부분을 읽는 행위 => DPI 라고 한다. (Deep packet Inspection)
    * 우리는 SPI가 합법화된 나라이다. (DPI는 무조건 문제가 된다.)

=> 따라서, ISP의 Sensor가 하는 역할은, SPI를 이용하는 것이다. 

=> 여기서 "망 중립성의 원칙" 이라는 용어 등장

=> (왜냐하면, SPI를 남발하면 ISP provider www.youtube.com 같은 사이트를 차단할 수도 있기 때문에, 이에 대한 남용을 금지하는 법.)



위를 통해, Sensor의 핵심 기술은 "놓치지 않고 수집하는 것" 임을 알 수 있다.

 



-- 약간 용어가 모호한 부분이 있기는 하지만, 계속 진행



### Proxy - 우회

아래의 2가지 목적이 있다,

* 서버 입장(www.abc.com)에서, 출발지가 "철수 본인의 IP 주소"이 아닌 "프록시 서버의 IP 주소" 로 인식하게끔 하기 위함

  => 이로 인해, 출발지의 정체를 숨기기 위한 목적

* ISP가 www.abc.com의 접속을 차단하게끔 한다면, (혹은 서버 www.abc.com이 철수의 접근을 차단한다면)

  => 철수는 프록시 서버를 설정해서, 프록시 서버를 통해 www.abc.com에 접속하게 된다.

  => 철수는 프록시 서버와 TCP/IP Connection을 맺게 되며, 반대로 프록시 서버와 Web Server는 또 다른 TCP/IP Connection을 맺게 된다.



따라서, Proxy 서버의 구조는 아래와 같이 요약이 된다.

* 소켓을 2개(Listen 소켓, Client 소켓)을 연다
  * Listen 소켓을 통해, 철수의 패킷을 받게 된다.
    * 해당 패킷에는, www.abc.com 에 연결해달라는 요청이 담긴 데이터(?)가 담겨 있다.
  * Proxy 서버는, Client 소켓을 통해 www.abc.com이 목적지인 패킷을 보낸다. (물론 이 때, 패킷의 출발지는 Proxy 서버의 외부 IP 주소이다.)
* 우회 목적의 Proxy 는, 네트워크 외부에 위치한다는 것이 특징





### Proxy - 보호, 감시

해당 Proxy 서버는 사내 네트워크에 있다는 것이 특징

* 사내 네트워크에 속하는 단말은, 무조건 Proxy서버를 통해서만 인터넷에 접속할 수 있게끔 방화벽을 (IPS를)설정하면 된다. 

  * IPS와 방화벽 차이는 찾아보기. 용어가 살짝 혼용해서 쓴 감이 있음.
  * 이로 인해, 프록시 서버에 남긴 기록을 토대로 감시가 된다.

* 또한, 인터넷을 통해 외부 사이트에서 파일을 다운로드 받을 때, 프록시 서버에서 "스트림 수준"으로 파일이 안전한지 검증이 가능하다

  * IPS나 방화벽은 패킷 수준으로 통과 여부를 결정하므로, 파일의 안전성을 검증하는데 한계가 있다는 점을 "프록시 서버" 가 보완해준다.

    

(현재까지 내용 다듬기 - 23.07.26)



### Reverse Proxy

* 정의 : 클라이언트 입장이 아닌, "서버 입장"에서의 프록시 서버

  *  즉, 서버 입장에서 진짜 웹서버를 보호하기 위한 서버

    * 따라서, 클라이언트는 www.abc.com 으로 요청할 때, 실제 서버의 IP가 아닌, 서버가 지정해 둔 프록시 서버(SSL accelerator)의 IP주소에 접근하게 된다. (DNS 질의할 때에도, 프록시 서버의 IP주소를 얻게 된다)

    * 보통 HTTPS 통신을 하게 되므로, 1차적으로 IPS에서는 데이터의 위험성까지는 검증하지 못한다.

      => 이를, 프록시 서버(SSL accelerator)에서 평문으로 바꾸는 작업을 한다. 이후 웹서버로 패킷이 전달되는 과정은 평문통신이며, 웹 서버에 도착하기 이전에 해당 데이터의 위험성을 검증하는 작업은 WAF 등에서 이루어진다. 



### PC에 설치하는 Proxy

Fiddler => Https 분석할 때 매우 유용한 도구



* Fiddler를 활용해서, host를 여러 개 쓰지 않고 local PC에 설치하는 Proxy 서버도 구현할 수 있다.

  * 이는, local PC에서, 프록시 서버 셋팅을 127.0.0.1:8080으로 해두면 된다.

    => 메모리상의 Fiddler 프로세스가 8080번 포트의 소켓을 열어두게 되며, 이 소켓으로, local의 요청을 받는다

    => 이후, local이 보내고자 하는 서버 목적지로 패킷을 보내게 된다.

  * 물론, Proxy 서버가 로컬에 깔려있다고 할지라도, local -> Proxy(local pc 설치) 통신 역시 Https 통신이며, Fiddler에서는 이를 복호화한다

    * 복호화하는 데이터는 stream 단위이므로, 결과적으로 분석이 더 용이하다



## 섹션1. 인터넷 공유기 작동원리

### 공유기 작동원리 및 개요

* 공유기 정의 : NAT(Network Address Translation) 기술이 적용된 장치
  * Network Address는 IP 주소를 의미하나, 실제로 공유기에서는 IP주소와 port번호까지 모두 제어한다.
  * IP헤더와 TCP헤더의 정보를 조작한다.
  * 공유기는 패킷 필터링 방화벽 수준의 보안성을 제공
    * 외부 해커가, 공유기를 사용하는 여러 host 중 특정 host를 찝어서 해킹할 수 없다.
      * 따라서, Worm Virus가 요즘에는 많이 없다.
        * P to P 통신이 많이 없기 때문. 따라서, NAT 기술이 적용된 공유기를 사용 시, P to P 통신은 방해를 받는다.

* NAT 공유기 구조(논리적 구조)에 따른 분류

  * Cone NAT

    * Host 단위로 외부 포트 지정

      * 따라서, 세션과 관계없이 매핑정보가 일정하다. 

        => 즉, 특별한 제한이 없다면(=full cone), 외부의 서비스는 매핑 정보를 토대로 호스트로 패킷을 보낼 수 있다.

    * 종류는 아래와 같다

      * Full Cone
      * Restricted Cone
        * IP Address restricted
        * Port restricted

  * Symmetric NAT

    * TCP 세션 단위로 외부 포트 지정

      * 기본적으로 제한 범위는 Port Restricted 수준이다.

      * 또한, 세션마다 외부 포트를 달리 부여

        => 보안성이 Cone NAT 보다 뛰어나다



* 참고할 만한 사항
  * private IP 대역(192.168.X.X, 172.16.X.X, 10.X.X.X 등)은 public IP 대역으로 사용할 수 없다. 







참고

* Cone 방식의 NAT와 Symmetric 방식의 NAT에 대한 설명
  * 출처 : https://tomatohj.tistory.com/42



### Symmetric NAT 방식

일단, Packet에서 IP헤더와 TCP헤더에서 각각 IP주소와 PORT번호가 어떻게 바뀌는지 관찰할 것이다.



최초 출발지(클라이언트)의 포트 번호는, OS가 아무거나 열어서 mapping 해 준다.

* 이후, NAT에서 패킷이 outbound될 때, TCP/IP 헤더가 조작됨

  => 출발지의 IP주소/PORT 번호가 바뀐다. (이 떄, 여기서는 NAT의 외부 IP주소와 PORT 번호가 할당된다.)

  => 웹 서버는, 실제 PC(클라이언트)의 IP주소/PORT 번호가 아닌, NAT Gateway와 연결되어 있다고 생각한다.

* NAT를 통해 웹 서버로 트래픽이 outbound 될 때, NAT Gateway는 아래의 기록이 남게 된다.

  * | Local Ip     | Local Port | External Port | Remote IP   | Remote Port | Protocol |
    | ------------ | ---------- | ------------- | ----------- | ----------- | -------- |
    | 192.168.0.10 | 3000       | 23000         | 15.15.15.15 | 80          | TCP      |
    | 192.168.0.12 | 2500       | 23001         | 15.15.15.15 | 80          | TCP      |

  * ★ 참고로, 웹 서버로부터 패킷이 inbound될 때에는, NAT Gateway에 기록이 남지 않는다. 
  * 따라서, TCP 연결 시도 시, 서버로부터의 응답(SYN +ACK) 이 올 때, NAT TABLE을 활용하여 공유기와 연결된 호스트 중 원하는 호스트를 찾는다.
    * 이 때의 패킷은 아래와 같으며, inbound 직후에는 External IP -> LOCAL IP, External Port -> Local Port로 변환된다.
      * (NAT Gateway 도착 직전)
        * IP 헤더 : src 15.15.15.15 / dst 3.3.3.3
        * TCP 헤더(Port) : src 80 / dst 23000
      * (NAT Gateway 도착 후)
        * IP 헤더 : src 15.15.15.15 / dst 192.168.0.10
        * TCP 헤더(Port) : src 80 / dst 3000  



* 위 과정에서 보면, 웹 서버 입장에서는 공유기랑 통신한다고 생각하지만, Local Pc host 입장에서는 실제 웹 서버랑 통신한다고 생각한다

  * 이는, 공유기로 인해 접속 정보의 착각이 일어났다고 할 수 있다.

  * 따라서, 아래의 상황이 가능

    * 공유기와 연결된 2대의 host가 웹 서버 A에 접속 시, 공유기는 아래와 같이 IP주소 / PORT 번호를 변경할 것이다
      * IP주소 / PORT번호 (변환 이후) => 3.3.3.3 / 20000, 3.3.3.3 / 20001
      * 위의 정보를 토대로 IP 패킷이 만들어지게 되어서 서버로 전달되면, 서버 입장에서는 1개의 호스트가 2번 요청했다고 착각한다
        * 하지만 실제로는 2대의 호스트가 1번씩 요청한 것이며, 이는 NAT 기술이 적용된 공유기 덕분이다.

    



참고

* NAT 게이트웨이는, 기본적으로 Inline 장비가 된다.



### Full Cone 방식과 내부 네트워크 접속 문제

NAT Gateway는 패킷 필터링 역할을 하기도 한다.

* Inbound된 패킷이, NAT 테이블에 존재하지 않으면, 해당 패킷은 어느 호스트로 보내야 할 지 NAT Gateway가 판단하지 못한다

  => 해당 패킷은 drop 된다.



Full Cone 방식

* 내부 Host의 IP와 PORT를 NAT Gateway의 External Port와 대응시키는 NAT Table을 만든다

  * 이 때, 접속하는 서버에 대한 IP 주소 / 포트 번호에 대한 제한사항은 없다.

    | Local Ip     | Local Port | External Port | Remote IP | Remote Port | Protocol |
    | ------------ | ---------- | ------------- | --------- | ----------- | -------- |
    | 192.168.0.10 | 3000       | 8080          | Any       | Any         | TCP      |

  * 즉, 내부 호스트의 IP/PORT를 외부 공개용 IP/PORT로 변환시켜 놓았다고 볼 수 있다. (외부에서 마음대로 내부 호스트에 접속 가능!)

* 좋은 점

  * 상황에 따라 P to P 통신을 가능하게끔 할 수 있다.

    * 1차적으로 랑데뷰 서버(?)랑, "공유기를 사용하는" 호스트와 통신한다

      => 해당 공유기의 NAT table에 정보가 기록된다.

    * 이제, 실제 게임 서버는 위의 랑데뷰 서버로부터 클라이언트의 public IP / port를 전달받는다

    * 게임 서버는 직접적으로 클라이언트로 (= 내부 호스트) 접속할 수 있다

  * 보안이 다소 떨어진다는 단점이 존재하지만, hole punching이 잘 된다는 장점이 있다.

    *  





참고

* 홀 펀칭

  * P2P 통신을 위해서, 양 쪽 클라이언트 A,B가 통신 시, 서로 연결하고자 하는 public IP주소 / port 번호 & private IP 주소 / port 번호를 알아내는 기법

  * A,B 만으로는 위 기술 구현이 불가능하며, 중간에 중개하는 서버가 1대 더 있어야 한다

    => 해당 중개 서버는 A,B로부터 각자의 public IP주소 / PORT 번호 & private IP주소 / PORT 번호를 받는다

    => 그리고 중개 서버는 A에게 B의 정보를, B에게 A의 정보를 주는 것으로 역할을 다 한다

    => 이후, A와 B는 받은 정보를 토대로 연결을 시도한다

    => 이 때, A와 B가 다른 네트워크 상에 있다고 가정할 때 아래와 같은 일이 일어나며 이를 "홀 펀칭" 이라고 부른다.

    * NAT - A에는, B로 패킷(UDP 다이어그램)을 보낼 때 NAT - A에는 "홀 펀칭"이 일어난다.

      => 즉, NAT - A에는 "A의 private ID 종점/PORT번호" 와 "NAT-A의 public ID / PORT번호" 가 기록된다.

      => 즉, 인터넷 상으로는 NAT-A의 public ID / port번호 와 NAT-B의 public ID/ port 번호 가 기록된다.

    * NAT-B 에서도, A로 패킷(UDP 다이어그램)을 보내게 될 때, 위와 동일한 현상이 일어난다.

    * 이제, public IP /PORT 정보를 토대로, 서로 다른 네트워크 범위에 있는 A와 B가 통신이 성공하게 되면, private IP/PORT 정보를 활용한 통신 시도는 자연스럽게 중단된다.

  * 출처

    * https://bjh0925.tistory.com/entry/%ED%99%80%ED%8E%80%EC%B9%AD%EA%B3%BC-%EB%9E%91%EB%8D%B0%EB%B7%B0 (조금 더 보완하기)
    * https://program-factory.tistory.com/7 (대략적인 개념)



(내용 조금 더 다듬기 - 23.07.27)





### (IP) Restricted Cone 방식

NAT Table에서, 호스트로 향하는 인바운드 패킷에 대해, IP주소를 특정 IP주소만 받아들임

=> 원격지 Port 번호는 제한이 없다.

=> 아예 원격지 IP주소가 다른 서버에서 보내는 패킷은, drop 된다.



### Port Restricted Cone 방식

호스트에 대고, 포트번호 매핑할 때, 최대한 있는 번호를 그대로 쓴다.

=> 즉, 라우터의 포트번호를 어느 정도는 유지한다

​	=> 따라서, 동일한 호스트에 대해 다른 프로세스(=다른 포트번호)가 web server A(15.15.15.15)에 요청을 보낼 때, 

​		 NAT 게이트웨이에는 모두 External Port가 동일한 번호로 매핑된다. 

=> 보안성이 떨어진다. (즉, 포트번호가 예측이 어느 정도 가능하다.)



* NAT를 쓰는 목적

  * 완전히 보안 때문에 NAT를 쓰는 것이 아니라면, 여러 호스트가 인터넷을 잘 쓰기 위함임.

    => P to P 통신이 방해가 될 수 있다.

    (논리가 완전하지는 않게 느껴짐)

    * (내 생각에는), Cone 방식의 NAT를 구성 시, HOST의 어느 프로세스로 서버의 패킷이 도달해야 할 지 NAT TABLE만으로는 판단이 안 되므로 P TO P 통신이 방해가 될 지 싶다. 



* Symmetric 방식과 Port Restricted Cone 방식의 차이
  * 제한 범위는 같음
  * 그러나, 동일한 호스트에서 서로 다른 프로세스가 서버로 요청할 때, External Port를 "다르게" 매핑하는 것이 Symmetric 방식이다. 



참고

* 세션의 식별자는 아래와 같이 4가지로 구성된다.
  * LOCAL IP,PORT + Remote IP,PORT
    * 이 중 어느 것 하나라도 달라지면 식별을 한다.
  * 출처 : https://www.inflearn.com/course/lecture?courseSlug=%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC%EC%9D%B4%EB%A1%A0-%EC%9D%91%EC%9A%A9&unitId=127010&category=questionDetail&tab=community&q=851592



### 포트 포워딩

외부 서버 A가, 접속한 적이 없는 네트워크 대역(Nat Gateway 사용)에 직접 접근을 허용을 하고 싶다면?

=> NAT Table을 직접 수정하면 된다.

=> 이를 좀 더 응용하면, P2P 통신이 가능하게끔 할  수 있다. (외부 PORT를 ANY로 설정.) 



생각해 보아야 할 사항) 게임을 할 때 P2P 통신은 필수적이라고 할 수 있다.(속도의 차이)

=> 이 때, 게임할 때 새로운 유저를 만날 때마다 위의 "포트 포워딩" 작업을 수동으로 해야 할까? 

=> 자동으로 하는 기술이 존재



### UPnP와 NAT

보통의 경우에는 모든 공유기가 UPnP를 지원한다. 이 기능이 포트포워딩을 자동으로 해 준다.

=> 따라서, P to P 통신 이슈가 해결한다.

=> 물론, 공유기가 UPnP를 지원하고, SSDP 프로토콜에 반응해야 한다는 전제에서이다.

=> 대표적인 예는, 공유기 뒤편 너머의 호스트가 "Torrent" 서비스를 실행할 때, UPnP로 인해서 P2P 통신이 원활하게 된다.



* PnP(Plug and Play)의 역사

  * PnP가 나온 이후에, 운영체제에 직접 무언가가 설정할 일이 획기적으로 줄어듦.
    * PnP 개념이 등장하면서, 프린터기를 컴퓨터와 연결하기만 하면, PC가 알아서 windows 서버까지 가서 드라이버를 자동으로 설치되므로.

* UPnP(Universal PnP)

  * 여기에 포함된 스팩이 SSDP이다.

    * 토렌트가 SSDP를 지원한다. 따라서, 공유기 뒤편 호스트에서 토렌트가 실행되면, 토렌트는 네트워크 속의 공유기에다가 아래와 같이 문의함.

      => "PtoP 통신을 할 건데, 설정 자동화 부탁할게"

      => 공유기는 "UPnP 서비스를 지원하고 있으니, 설정 자동화 할게" 라고 응답함.

      => 포트 포워딩 서비스를 자동으로 해 줌으로서, PtoP 통신은 해결된다.



나의 생각) 좀 더 깊게 보면 다른 의미이기는 하나, 지금은 이쯤에서 파는 걸로 마무리

* 참고할 만한 출처
  * https://www.joinc.co.kr/w/Site/IOT/Discovery
  * https://nordvpn.com/ko/blog/upnp-igd/





## 섹션2. 부하분산 시스템 작동원리

### L4 부하분산과 무정지 시스템

공유기의 원리를 알게 되면, 부하분산의 원리를 쉽게 이해할 수 있다.

=> L4 스위치는, 포트 번호를 기반으로 스위치한다.



* L4 스위치는 부하 분산(로드 밸런싱)에 쓰인다.

  * L4 스위치는, 원래의 웹 서버를 클론한 n개의 웹 서버 중 1곳으로 트래픽을 보낸다

    * 이 때, 단순히 n개의 웹 서버에 순서대로 트래픽을 보내는 것을 "Round Robin" 이라고 한다

      => 실제로는 이렇게 안 하며, Health Check가 동반된다.

      * 즉, 별도의 Managing Server가 존재하며, 이 서버는 로드밸런서 및 n개의 웹 서버에 연결되어 있다

        => Managing Server는 n개의 웹 서버의 부하율을 측정하여, 가장 부하가 낮은 웹 서버를 로드밸런서에게 알려준다

        => 로드밸런서는 해당 웹 서버로 트래픽을 보낸다

  * 만약, 웹 서버 중 1곳이 부하율이 너무 높거나 장애가 발생한다면?

    * Managing Server는 해당 웹 서버를 격리시키며, 추가의 (클론된) 웹 서버를 투입한다

      => 이 과정에서, 클라이언트 입장에서는 항상 로드밸런서와 통신하고 있기 때문에, 서버가 정지되어 있다고 느끼지 않는다.

      => "무정지 시스템" 이 가능해진다.

      => 해당 격리된 웹 서버는 A/S 에 돌입하게 된다.

  * 그런데, 위의 과정이 모두 가상화가 되어 있다면?

    * 즉, 로드 밸런서와 웹 서버들, 그리고 Managing 서버가 모두 가상화가 되어 있다면?

      => 보안 패치 등 관리가 용이해진다. 배포의 자동화도 가능해진다.

      => 장애가 발생해도, 스냅샷을 찍은 후 문제를 해결하여 다시 리부팅을 하면 된다.

      => DOCKER 기술이 등장하며, kubernetes 기술 역시 등장한다.

      => 이는 "최신 트렌드" 이다!

    * 따라서, 예전에는 스위치 등의 장비를 물리적으로 설치했다면, 이제는 위의 과정을 대신해주는 "Cloud Service"를 제공해주는 업체가 등장

      

### 대규모 부하분산을 위한 GSLB

* 구글, 네이버 정도의 기업에서는 로드 밸런싱 문제가 정말 머리 아프다. Global 하게 부하를 분산해야 한다
  * 이 때는 DNS를 활용한다.
  * 범지구적 수준(=global 수준)에서의 로드 밸런싱 문제는, Health Check 결과는 물론이며 클라이언트의 지리적 위치까지 고려해야 한다. 
  * 그리고 전 세계에 퍼져 있는 웹 서버에 대해서, 컨텐츠가 "동시에" Update 되어야 한다
    * 이를 수행해주는 업체가 존재(CDN - Contents Delivery Network)



국내의 경우를 파악하고 난 후, 글로벌하게 부하를 분산하는 방법에 대해 알아보자

* 간단한 서비스를 제공하는 경우라면, 1대의 서버(혹은 LB)가 트래픽을 담당할 것이다.

  => 해당 서버의 도메인 주소를 www.abc.com 이라고 하자.

  => 그러나, 트래픽이 증가하면 여러 대의 서버로 효율적으로 트래픽을 분산시켜야 한다.

  * 따라서, 각 통신사 ISP와 연결된(? - 용어가 다소 불확실) 웹 서버를 1대씩 둔다

    * 각 웹서버마다 canonical alias 도메인을 부여

      예) KT ISP와 연결된 웹 서버에는 a.www.abc.com을 부여, U+ ISP와 연결된 웹 서버에는 b.www.abc.com 부여

    * 이제, KT ISP와 연결된 클라이언트가 www.abc.com 에 접속하는 과정은 아래와 같다

      1') 클라이언트는, www.abc.com 의 ip주소를 질의 (KT DNS 서버에 질의)  

      2') a.www.abc.com 으로 접속하라는 회신을 클라이언트가 받음.

      3') 클라이언트는 a.www.abc.com의 ip주소를 질의 (KT DNS 서버에 질의)

      4') 회신받은 IP주소를 토대로, 클라이언트는 a.www.abc.com에 접속

      * 이 때, 모든 웹 서버의 컨텐츠는 동기화되므로, 클라이언트가 보는 컨텐츠는 www.abc.com 과 차이가 없다. (그래야만 하고.)

  * 따라서, 웹 서버가 그룹으로 묶을 수 있으므로 트래픽이 효과적으로 움직인다.

    => 네트워크 성능이 향상된다고 말할 수 있다.

  * 위의 웹 서버를 Managing 해 주는 서버가 필요하며, 웹 서버의 컨텐츠를 모두 동기화해주는 작업 역시 필요

    * 이는 CDN 과 연관된(? - 용어 부정확) 회사가 수행한다.

  * Windows 기준으로, 명령 프롬프트에 nslookup을 치고 난 후, 도메인 이름을 치게 되면 canonical alias를 확인할 수 있다.



* 글로벌하게 부하를 분산시키는 경우도 위와 똑같은 원리이다.

  * 클라이언트의 지리적 위치는, IP주소를 토대로 파악이 된다

    * 클라이언트가 어느 ISP를 쓰는지, 어느 도시에 있는지까지 파악이 된다.

      => 이는, IP주소에 대한 위치 데이터 등을 담은 DB가 있기 때문에 가능 (담당 회사 - 맥스마인드)

    * 따라서, 게임에서 중국에서 접속 시 중국서버로 접속되며 한국에서 접속 시 한국서버로 접속이 되는 이유도 이러한 원리에서이다.



(내용 조금 더 다듬기 - 23.07.28)



## 섹션3. VPN과 네트워크 보안 솔루션

### PN과 VPN

서론

* 회사의 DB 서버가 부산에 있고, 회사의 본사는 서울에 있다고 하자

  * 여기서, 서울과 부산간에 Private Network 망을 설치하려면, KT에게 문의해서 "우리 회사 전용 회선" 을 설치해 달라고 하면 된다.
    * 보안성이 우수하다.
    * 그러나, 비용이 너무 많이 들며, 속도도 느리다고 한다.

  => 생각해야 할 점은, "인터넷" 을 활용하되, 보안 문제만 해결하면 될 것이다.

  => VPN 등장



VPN 기술

* 인터넷이라는 오픈된 네트워크를 인프라로 쓰되, 보안성을 확보해서 Network를 "LEN" 처럼 확대하는 기술
  * 데이터의 무결성과 기밀성을 유지하게끔 한다
    * 그래서, 데이터가 암호화되어서 공개 네트워크의 누군가가 봐도 모르므로 보안성이 확보된다,
  * 터널링 기술
    * 본질은 무결성과 기밀성이다.
    * 위 본질을 토대로, 두 네트워크를 "논리적으로" 연결하여 가상의 사설망을 구성하는 기술



### IP Sec VPN 과 터널링 개념

VPN을 구현하는 프로토콜은 여러 개가 있다.



IP Sec Protocol은 L3 수준의 보안을 제공하므로, 모든 IP기반 통신을 보호할 수 있다

* G to G VPN 구현을 위해서 IP Sec는 많이 사용된다.
  * G는 게이트웨이이다.





참고

* Router에 IP Sec 보안 기능을 제공하면, SG(Secure Gateway)라고 한다





G to G VPN 구현

* G to G VPN 통신 시, 아래의 과정에 의해, 서울 지사의 컴퓨터에서 부산 지사의 컴퓨터까지 "무결성 & 기밀"을 유지하면서 통신한다
  * 서울 지사의 컴퓨터에서 IP 패킷을 만든다.
    * 이 때, IP헤더의 정보는, 출발지는 서울지사 컴터 IP 주소 / 도착지는 부산지사 컴터 IP 주소를 담는다.
    * 해당 IP 패킷은 서울 지사의 SG까지 도달
  * SG(서울 쪽)에서는 위의 패킷을 복호화하며, 새로운 IP헤더를 붙임
    * 이 때 새로운 IP헤더는 src : 서울 SG IP주소 / dst : 부산 SG IP주소 를 담는다
    * 각 SG의 src/dst의 외부로의 노출까지는 막을 수 없다.
    * 하지만, inner IP헤더()와 payload는 모두 암호화되어 있어서, 외부에서 봐도 모른다.
  * 목적지의 SG(부산 쪽)에 도착하면, 이 때 바깥쪽 IP 헤더는 제거하고, 내부 패킷을 복호화 함
    * 이후, 목적지 호스트까지 패킷을 전달함.
* 위의 과정은 한 마디로, IP 패킷을 암호화 한 후, "L3 IP 헤더"로 감쌌다.
  * "L3 Tunneling" 과정이 적용되었다.

  

### VPN과 재택근무

재택근무는 G to E VPN 으로 구현될 수 있다

* 부산 지사에서 근무하는 철수는, 부산의 자기 집(IP 주소 9.9.9.9)에서 서울 지사의 회사의 서버(IP주소 5.5.5.100)에 접속하려고 한다

  * 부산 지사의 SG의 IP 주소는 3.3.3.1, 서울 지사의 SG의 IP 주소는 5.5.5.1이다.

  * 이 때, 철수는 VPN Client 프로그램이 깔려있으며, 이는 부산 지사의 SG와 통신하기 위해서 설치

    * 철수는 해당 VPN Client 프로그램으로 인해, 본인의 기존 IP(9.9.9.9) 이외에 추가의 IP(3.3.3.50)을 할당받는다.
    * 따라서, 철수가 서울 회사 웹 서버(IP 주소 5.5.5.100) 으로 보낼 때는 IP패킷의 정보가 아래와 같다
      * 맨 앞 헤더(암호화 되지 않음)
        * src : 9.9.9.9 / dst : 3.3.3.1
      * 중간 ip 헤더(복호화)
        * src : 3.3.3.50 / dst : 5.5.5.100 => 따라서, 서울 지사 측에서는 철수가 재택 근무인지 모르게 된다.
      * payload (복호화)
    * 이제 위의 정보를 가진 패킷은 철수 집 -> 부산 지사 SG로 보내지게 된다.
      * 이 과정에서, 철수 집 -> 부산지사 SG 사이에서는 터널링 기술이 적용되어 있다.

  * 부산지사 SG에서는 아래와 같은 과정으로 서울지사 SG로 보낸다

    * 철수한테 받은 IP 패킷 중, 맨 앞 헤더 제거
    * 그리고 패킷의 나머지 부분을 모두 복호화
    * 위의 패킷을 다시 암호화한 후, 새로운 IP 헤더를 앞에 붙임
      * 새로운 IP헤더의 정보
        * src : 3.3.3.1 / dst : 5.5.5.1
    * 역시, 부산 SG와 서울 SG 사이에서는 터널링 기술이 적용되어 있다.

  * 서울지사 SG에서는, 위 패킷을 받게 되면, 맨 앞 IP헤더 제거 & 나머지 패킷 복호화를 진행

    => 웹 서버로 패킷을 보내게 된다.

​	

### VPN 악용

VPN의 본래 목적은 Network의 확장 및 연계이다.

* 하지만, 원래의 IP주소를 숨길 수 있다는 점 때문에 아래의 여러가지 문제점이 발생할 수 있다

  * A국가에서 B국가 게임 서버 접속 가능

    => B 국가 게임 서버의 질서를 흐릴 수 있다.

  * 인터넷 자정 작용에 의해, VPN으로 할당받은 IP주소로 나쁜 짓을 하다가 해당 IP주소가 제재를 받는다고 하자.

    * 그럼에도, 본래 나쁜 짓을 한 사람의 IP주소는 아무 이상 없으므로, 다시 VPN으로 IP주소를 또 다시 할당받아서 나쁜 짓을 할 수 있다.

 

VPN Protocol은 PPTP 도 있으며, IPTIME 공유기에서 지원을 한다.

* 따라서, 아래의 안 좋은 상황이 가능하다.
  * 블랙 해커가 일반인의 공유기를 해킹해서, 해당 공유기에 VPN 계정을 설정
    * 그리고 나쁜짓을 하게 되면, 일반인은 고발당하지만 해커는 뒤로 쏙 빠지게 된다.
  * 해커를 추적해도 못 잡을 확률이 높다.



(23.07.29 - 그림 추가해서 조금 더 정리)

### 네트워크 보안 솔루션 종류

