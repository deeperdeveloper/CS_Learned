구조가 3가지 중에 무엇인지 따져보는 습관



### 세 가지 네트워크 장치 구조



Inline은 공기 청정기 생각하기

=> 대표적인 장치가 "라우터"



Out of Path는 다루는 데이터 단위는 같으나, 차단/허용의 개념이 아니라, "인지"(즉 읽기) 가 주 목적

=> 보안상 이슈를 "인지" 하면 보안센서이다.

=> 네트워크 장애를 "인지"하면 장애센서 이다.



따라서, 네트워크 센서라고 하면 거의 Out Of path 구조이다.

** Tab 스위치를 통해서, 패킷을 복사받고 분석해서 센서가 결과를 알려줌.



Proxy는 데이터 단위가 "스트림 수준" => 스트림 데이터를 볼 수 있다는 장점이 있다.

(예) 10MB 파일을 보려면(=패킷에서 스트림을 얻으려면), 거의 10000개의 패킷을 조립해야 한다. 이는 굉장히 어려운 일이다.)

=> 따라서, 파일 수준의 데이터 단위를 다룰 떄, Proxy 구조를 다룬다.

=> 구조 자체는 Inline과 비슷(Drop/Bypass 기능이 있다.)

=> But, ReadOnly는 존재하지 않는다. 

(대리자를 통해서 지나가는 개념이라, 어플리케이션 전체를 모니터링 한다. )



 (노트 그림 보기)



### Inline 구조

-Inline 구조

고속도로(네트워크)에서 자동차(패킷)이 움직일 때는, 톨게이트를 반드시 통과해야 한다.



inline구조의 예) 공유기, 라우터, 방화벽(패킷 필터링 방화벽), IPS 등



=> 이처럼, 어느 한 컴퓨터에서 다른 서버로 접속할 때, 여러 Inline 장치를 거쳐서 도달하게 된다.





라우터도 "랜카드가 여러 개 달린" 컴퓨터라고 생각하면 되게 쉽다!



<라우터의 구조>

택배기사가 물건을 받았다고, 소유권이 택배기사에 있는 것이 아니듯이, 라우터는 "남의 데이터"를 받아서 byPass나 drop을 결정한다.



=> 구현은 커널모드에서 이루어진다(당연히, 입출력속도가 커널모드가 user Mode보다 훨씬 빠르기 때문이다.)



(그림 참조)

가속 NIC은, 커널모드에서 이루어지는 작업(IP 패킷 분해 등)을 하드웨어 수준에서 처리한다

=> 이는, 순전히 속도 문제 때문이다.

=> 따라서, Inline Device는 "Throughput"이라는 용어까지 있을 정도이다. 

(예를 들어 네트워크가 10Gbps 급이라도, 중간에 Router 하나가 1Gbps 급이라면 전체 네트워크 성능은 하향평준화가 될 수 밖에 없다.)

=> 그래서, 하드웨어 수준에서 들어오고 나가고를 바로 하는 것이 가장 이상적

=> 따라서, 하드웨어와 inline module(즉, s/w)의 기능의 절충안을 찾는 것이 가장 일반적.



=> 이제 정리하면, Inline Device는 들어온 패킷을 Drop하거나 pass 시킬 수 있다. 어떤 로직으로 이러한 것을 결정하는 가에 따라, Inline Device의 성격이 완전히 바뀐다.





** 여담으로, Router역시 컴퓨터이다. 따라서, 아래의 경우도 가능하다

* Router에 windows 운영체제 설치

* 내 컴퓨터에 Router에서 사용하는 OS 설치

  => 이 경우, 내 컴퓨터는 Router 역할을 한다

=> 따라서, Cisco는 단순히 H/W 회사 뿐만 아니라, Inline Device기능을 하도록 S/W 모듈과 자체 OS까지 같이 만드는 회사라고 볼 수 있다.



### Out of path 구조와 DPI 그리고 망중립

Out of Path의 또다른 이름은 "Sensor" 이다.

=> Sensing할 네트워크 장비가 있어야 한다.

=> "L2 수준에서의 Port Mirroring"이다. (즉,  패킷이 유통될 때, 복사해서 보자라는 의미이다.)

=> 즉, 스위치가 스위칭하는 모든 L2 Frame을 어느 특정 다른 port로 copy한다는 의미이다.

 



Mirroring은 부하가 많이 걸리므로, 하드웨어 적으로 우수해야 한다.

=> 스위치 중, "Tab switch" 라고 있음 (Mirroring만 전문적으로 함)

=> 해당 스위치의 port가 10개라면, 8개의 포트가 mirroring 역할을 수행한다. (2개 포트를 통해 switch를 통과하는 패킷을 대략 8곳에 복사하는 역할을 한다. )

=> 따라서, 부하가 많이 걸리므로, 고성능이다.

=> 이렇게 많이 복사하는 이유는, 2개는 보안에 쓰고, 2개는 장애 대응에 쓰고..... 등이다.



Out of path의 목적은, "분석" 혹은 "탐지"의 목적이다.

=> 따라서, Sensor는, "수집 장치"라는 단어와 항상 따라다닌다.



#### 반사회적 사이트 접속 차단 원리

* www.abc.com 입력 시, warning 페이지가 뜨게 하려면 아래와 같다 (대략적인 설명)

  1. ISP 수준에서 패킷을 수집한다.
  2. Sensor(Out of Path 구조 Device)가 해당 사이트가 접속하면 안 되는 사이트임을 인지
  3. 위의 Device가 거짓응답을 클라이언트에게 보내서, www.abc.com의 응답결과로 warning 페이지가 보이게끔 한다.

  

  

* 아래의 용어를 알아야 한다.

  * L7 HTTP 수준에서 알아야 할 용어

    * TCP/IP 헤더 이외에 HTTP 헤더를 들여다 보는 행위 => SPI 라고 한다. (Shallow packet Inspection)

    * 그리고 data 부분을 읽는 행위 => DPI 라고 한다. (Deep packet Inspection)
    * 우리는 SPI가 합법화된 나라이다. (DPI는 무조건 문제가 된다.)

=> 따라서, ISP의 Sensor가 하는 역할은, SPI를 이용하는 것이다. 

=> 여기서 "망 중립성의 원칙" 이라는 용어 등장

=> (왜냐하면, SPI를 남발하면 ISP provider www.youtube.com 같은 사이트를 차단할 수도 있기 때문에, 이에 대한 남용을 금지하는 법.)



위를 통해, Sensor의 핵심 기술은 "놓치지 않고 수집하는 것" 임을 알 수 있다.

 



-- 약간 용어가 모호한 부분이 있기는 하지만, 계속 진행



### Proxy - 우회

아래의 2가지 목적이 있다,

* 서버 입장(www.abc.com)에서, 출발지가 "철수 본인의 IP 주소"이 아닌 "프록시 서버의 IP 주소" 로 인식하게끔 하기 위함

  => 이로 인해, 출발지의 정체를 숨기기 위한 목적

* ISP가 www.abc.com의 접속을 차단하게끔 한다면, (혹은 서버 www.abc.com이 철수의 접근을 차단한다면)

  => 철수는 프록시 서버를 설정해서, 프록시 서버를 통해 www.abc.com에 접속하게 된다.

  => 철수는 프록시 서버와 TCP/IP Connection을 맺게 되며, 반대로 프록시 서버와 Web Server는 또 다른 TCP/IP Connection을 맺게 된다.



따라서, Proxy 서버의 구조는 아래와 같이 요약이 된다.

* 소켓을 2개(Listen 소켓, Client 소켓)을 연다
  * Listen 소켓을 통해, 철수의 패킷을 받게 된다.
    * 해당 패킷에는, www.abc.com 에 연결해달라는 요청이 담긴 데이터(?)가 담겨 있다.
  * Proxy 서버는, Client 소켓을 통해 www.abc.com이 목적지인 패킷을 보낸다. (물론 이 때, 패킷의 출발지는 Proxy 서버의 외부 IP 주소이다.)
* 우회 목적의 Proxy 는, 네트워크 외부에 위치한다는 것이 특징





### Proxy - 보호, 감시

해당 Proxy 서버는 사내 네트워크에 있다는 것이 특징

* 사내 네트워크에 속하는 단말은, 무조건 Proxy서버를 통해서만 인터넷에 접속할 수 있게끔 방화벽을 (IPS를)설정하면 된다. 

  * IPS와 방화벽 차이는 찾아보기. 용어가 살짝 혼용해서 쓴 감이 있음.
  * 이로 인해, 프록시 서버에 남긴 기록을 토대로 감시가 된다.

* 또한, 인터넷을 통해 외부 사이트에서 파일을 다운로드 받을 때, 프록시 서버에서 "스트림 수준"으로 파일이 안전한지 검증이 가능하다

  * IPS나 방화벽은 패킷 수준으로 통과 여부를 결정하므로, 파일의 안전성을 검증하는데 한계가 있다는 점을 "프록시 서버" 가 보완해준다.

    

(현재까지 내용 다듬기 - 23.07.26)



### Reverse Proxy

* 정의 : 클라이언트 입장이 아닌, "서버 입장"에서의 프록시 서버

  *  즉, 서버 입장에서 진짜 웹서버를 보호하기 위한 서버

    * 따라서, 클라이언트는 www.abc.com 으로 요청할 때, 실제 서버의 IP가 아닌, 서버가 지정해 둔 프록시 서버(SSL accelerator)의 IP주소에 접근하게 된다. (DNS 질의할 때에도, 프록시 서버의 IP주소를 얻게 된다)

    * 보통 HTTPS 통신을 하게 되므로, 1차적으로 IPS에서는 데이터의 위험성까지는 검증하지 못한다.

      => 이를, 프록시 서버(SSL accelerator)에서 평문으로 바꾸는 작업을 한다. 이후 웹서버로 패킷이 전달되는 과정은 평문통신이며, 웹 서버에 도착하기 이전에 해당 데이터의 위험성을 검증하는 작업은 WAF 등에서 이루어진다. 



### PC에 설치하는 Proxy

Fiddler => Https 분석할 때 매우 유용한 도구



* Fiddler를 활용해서, host를 여러 개 쓰지 않고 local PC에 설치하는 Proxy 서버도 구현할 수 있다.

  * 이는, local PC에서, 프록시 서버 셋팅을 127.0.0.1:8080으로 해두면 된다.

    => 메모리상의 Fiddler 프로세스가 8080번 포트의 소켓을 열어두게 되며, 이 소켓으로, local의 요청을 받는다

    => 이후, local이 보내고자 하는 서버 목적지로 패킷을 보내게 된다.

  * 물론, Proxy 서버가 로컬에 깔려있다고 할지라도, local -> Proxy(local pc 설치) 통신 역시 Https 통신이며, Fiddler에서는 이를 복호화한다

    * 복호화하는 데이터는 stream 단위이므로, 결과적으로 분석이 더 용이하다



## 섹션1. 인터넷 공유기 작동원리

### 공유기 작동원리 및 개요

* 공유기 정의 : NAT(Network Address Translation) 기술이 적용된 장치
  * Network Address는 IP 주소를 의미하나, 실제로 공유기에서는 IP주소와 port번호까지 모두 제어한다.
  * IP헤더와 TCP헤더의 정보를 조작한다.
  * 공유기는 패킷 필터링 방화벽 수준의 보안성을 제공
    * 외부 해커가, 공유기를 사용하는 여러 host 중 특정 host를 찝어서 해킹할 수 없다.
      * 따라서, Worm Virus가 요즘에는 많이 없다.
        * P to P 통신이 많이 없기 때문. 따라서, NAT 기술이 적용된 공유기를 사용 시, P to P 통신은 방해를 받는다.

* NAT 공유기 구조(논리적 구조)에 따른 분류

  * Cone NAT

    * Host 단위로 외부 포트 지정

      * 따라서, 세션과 관계없이 매핑정보가 일정하다. 

        => 즉, 특별한 제한이 없다면(=full cone), 외부의 서비스는 매핑 정보를 토대로 호스트로 패킷을 보낼 수 있다.

    * 종류는 아래와 같다

      * Full Cone
      * Restricted Cone
        * IP Address restricted
        * Port restricted

  * Symmetric NAT

    * TCP 세션 단위로 외부 포트 지정

      * 기본적으로 제한 범위는 Port Restricted 수준이다.

      * 또한, 세션마다 외부 포트를 달리 부여

        => 보안성이 Cone NAT 보다 뛰어나다



* 참고할 만한 사항
  * private IP 대역(192.168.X.X, 172.16.X.X, 10.X.X.X 등)은 public IP 대역으로 사용할 수 없다. 







참고

* Cone 방식의 NAT와 Symmetric 방식의 NAT에 대한 설명
  * 출처 : https://tomatohj.tistory.com/42



### Symmetric NAT 방식

일단, Packet에서 IP헤더와 TCP헤더에서 각각 IP주소와 PORT번호가 어떻게 바뀌는지 관찰할 것이다.



최초 출발지(클라이언트)의 포트 번호는, OS가 아무거나 열어서 mapping 해 준다.

* 이후, NAT에서 패킷이 outbound될 때, TCP/IP 헤더가 조작됨

  => 출발지의 IP주소/PORT 번호가 바뀐다. (이 떄, 여기서는 NAT의 외부 IP주소와 PORT 번호가 할당된다.)

  => 웹 서버는, 실제 PC(클라이언트)의 IP주소/PORT 번호가 아닌, NAT Gateway와 연결되어 있다고 생각한다.

* NAT를 통해 웹 서버로 트래픽이 outbound 될 때, NAT Gateway는 아래의 기록이 남게 된다.

  * | Local Ip     | Local Port | External Port | Remote IP   | Remote Port | Protocol |
    | ------------ | ---------- | ------------- | ----------- | ----------- | -------- |
    | 192.168.0.10 | 3000       | 23000         | 15.15.15.15 | 80          | TCP      |
    | 192.168.0.12 | 2500       | 23001         | 15.15.15.15 | 80          | TCP      |

  * ★ 참고로, 웹 서버로부터 패킷이 inbound될 때에는, NAT Gateway에 기록이 남지 않는다. 
  * 따라서, TCP 연결 시도 시, 서버로부터의 응답(SYN +ACK) 이 올 때, NAT TABLE을 활용하여 공유기와 연결된 호스트 중 원하는 호스트를 찾는다.
    * 이 때의 패킷은 아래와 같으며, inbound 직후에는 External IP -> LOCAL IP, External Port -> Local Port로 변환된다.
      * (NAT Gateway 도착 직전)
        * IP 헤더 : src 15.15.15.15 / dst 3.3.3.3
        * TCP 헤더(Port) : src 80 / dst 23000
      * (NAT Gateway 도착 후)
        * IP 헤더 : src 15.15.15.15 / dst 192.168.0.10
        * TCP 헤더(Port) : src 80 / dst 3000  



* 위 과정에서 보면, 웹 서버 입장에서는 공유기랑 통신한다고 생각하지만, Local Pc host 입장에서는 실제 웹 서버랑 통신한다고 생각한다

  * 이는, 공유기로 인해 접속 정보의 착각이 일어났다고 할 수 있다.

  * 따라서, 아래의 상황이 가능

    * 공유기와 연결된 2대의 host가 웹 서버 A에 접속 시, 공유기는 아래와 같이 IP주소 / PORT 번호를 변경할 것이다
      * IP주소 / PORT번호 (변환 이후) => 3.3.3.3 / 20000, 3.3.3.3 / 20001
      * 위의 정보를 토대로 IP 패킷이 만들어지게 되어서 서버로 전달되면, 서버 입장에서는 1개의 호스트가 2번 요청했다고 착각한다
        * 하지만 실제로는 2대의 호스트가 1번씩 요청한 것이며, 이는 NAT 기술이 적용된 공유기 덕분이다.

    



참고

* NAT 게이트웨이는, 기본적으로 Inline 장비가 된다.



### Full Cone 방식과 내부 네트워크 접속 문제

NAT Gateway는 패킷 필터링 역할을 하기도 한다.

* Inbound된 패킷이, NAT 테이블에 존재하지 않으면, 해당 패킷은 어느 호스트로 보내야 할 지 NAT Gateway가 판단하지 못한다

  => 해당 패킷은 drop 된다.



Full Cone 방식

* 내부 Host의 IP와 PORT를 NAT Gateway의 External Port와 대응시키는 NAT Table을 만든다

  * 이 때, 접속하는 서버에 대한 IP 주소 / 포트 번호에 대한 제한사항은 없다.

    | Local Ip     | Local Port | External Port | Remote IP | Remote Port | Protocol |
    | ------------ | ---------- | ------------- | --------- | ----------- | -------- |
    | 192.168.0.10 | 3000       | 8080          | Any       | Any         | TCP      |

  * 즉, 내부 호스트의 IP/PORT를 외부 공개용 IP/PORT로 변환시켜 놓았다고 볼 수 있다. (외부에서 마음대로 내부 호스트에 접속 가능!)

* 좋은 점

  * 상황에 따라 P to P 통신을 가능하게끔 할 수 있다.

    * 1차적으로 랑데뷰 서버(?)랑, "공유기를 사용하는" 호스트와 통신한다

      => 해당 공유기의 NAT table에 정보가 기록된다.

    * 이제, 실제 게임 서버는 위의 랑데뷰 서버로부터 클라이언트의 public IP / port를 전달받는다

    * 게임 서버는 직접적으로 클라이언트로 (= 내부 호스트) 접속할 수 있다

  * 보안이 다소 떨어진다는 단점이 존재하지만, hole punching이 잘 된다는 장점이 있다.

    *  





참고

* 홀 펀칭

  * P2P 통신을 위해서, 양 쪽 클라이언트 A,B가 통신 시, 서로 연결하고자 하는 public IP주소 / port 번호 & private IP 주소 / port 번호를 알아내는 기법

  * A,B 만으로는 위 기술 구현이 불가능하며, 중간에 중개하는 서버가 1대 더 있어야 한다

    => 해당 중개 서버는 A,B로부터 각자의 public IP주소 / PORT 번호 & private IP주소 / PORT 번호를 받는다

    => 그리고 중개 서버는 A에게 B의 정보를, B에게 A의 정보를 주는 것으로 역할을 다 한다

    => 이후, A와 B는 받은 정보를 토대로 연결을 시도한다

    => 이 때, A와 B가 다른 네트워크 상에 있다고 가정할 때 아래와 같은 일이 일어나며 이를 "홀 펀칭" 이라고 부른다.

    * NAT - A에는, B로 패킷(UDP 다이어그램)을 보낼 때 NAT - A에는 "홀 펀칭"이 일어난다.

      => 즉, NAT - A에는 "A의 private ID 종점/PORT번호" 와 "NAT-A의 public ID / PORT번호" 가 기록된다.

      => 즉, 인터넷 상으로는 NAT-A의 public ID / port번호 와 NAT-B의 public ID/ port 번호 가 기록된다.

    * NAT-B 에서도, A로 패킷(UDP 다이어그램)을 보내게 될 때, 위와 동일한 현상이 일어난다.

    * 이제, public IP /PORT 정보를 토대로, 서로 다른 네트워크 범위에 있는 A와 B가 통신이 성공하게 되면, private IP/PORT 정보를 활용한 통신 시도는 자연스럽게 중단된다.

  * 출처

    * https://bjh0925.tistory.com/entry/%ED%99%80%ED%8E%80%EC%B9%AD%EA%B3%BC-%EB%9E%91%EB%8D%B0%EB%B7%B0 (조금 더 보완하기)
    * https://program-factory.tistory.com/7 (대략적인 개념)



(내용 조금 더 다듬기 - 23.07.27)