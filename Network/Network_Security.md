# 외워서 끝내는 SSL과 암호기술 이론



## 섹션1. 기초이론

### 이름 궁합과 Checksum

* CheckSum(검사합)

  * 데이터가 변조되었는지 검사

  * 이 값은 자릿수를 유지한다. (= 즉, 최소한의 공간(?)만 차지한다.)

    => 이는 데이터를 활용해서 계산 시, 범위를 넘는 자리는 버림으로서 구현한다.

  * 보안성이 없으며 기밀성이 없다. 무결성도 없다

    * 보안성이 없으므로, 누군가가 원본의 CheckSum 값을 조작해서 보낼 수도 있으며, 수신측은 이를 인지하지 못하게 될 수 있다.

      => 따라서, Hash를 활용해서 CheckSum 값에 대한 보안성을 높인다.

  * 원본 데이터와 복사본 데이터가 일치하는지 확인하는데 쓰임

    * 원본 데이터를 보낼 때, CheckSum값을 별도로 보내며, 수신측에서도 복사본 데이터를 토대로 CheckSum값을 계산함

      => 2개의 CheckSum 값이 일치하면, 제대로 데이터가 송신되었다고 볼 수 있다.

  * 검사합 값을 토대로, 원본 문자열(데이터)을 복원하는 것은 불가능하다.

    * 오직, 원본 문자열 -> 검사합 값 으로 진행하는 단방향 로직만 가능
    * 마찬가지로, 위의 로직 진행 과정에서 원본 문자열의 각 문자가 변환된 어떠한 숫자(데이터)를 토대로 다시 복원시키는 것도 안 된다.



### Hash에 대해 외울 것들

Hash 함수 특징

* 단방향성

  * 즉, f(x) → y 이고, y값을 토대로 x를 추리하지는 못한다.

* 입력 값의 크기와 상관없이 결과 값의 길이(크기)는 항상 일정

  * 예를 들면, 해쉬 함수의 결과값으로 mod 연산값이라고 하면, 크기가 항상 일정하다.

* 데이터 무결성 확보와 관련해서 IT 기술 전반에서 사용된다.

  * 즉, 데이터가 절대 위조되지 않았다는 것을 증명하는 데에 사용됨

    => 따라서, CheckSum이 하는 일을 Hash가 대체하기도 한다. (물론 좀 복잡하긴 하다.)

* 좋은 해쉬 함수의 특징

  * 원본이 달라지면 결과값이 되도록 달라져야 한다.
    * 예) x % y -> 결과값일 때, x가 달라지면 결과값도 되도록이면 달라지게끔 해야 한다. 

* 홈페이지에 비밀번호를 저장할 때, 반드시 평문이 아닌 "암호화"하여 DB에 저장하여야 한다.

  * 이 과정에서, Hash 함수가 쓰인다.
  * 단방향 암호화이므로, 홈페이지 관리자도 PWD를 알아낼 수 없다.

* Hash 함수의 문제점 및 보완책

  * 단순히 비밀번호를 Hash 함수를 적용하여 저장하면, 해커가 DB를 해킹했을 때 역추적이 될 수 있다

    * 그래서, 사용자가 입력한 비밀번호에, 웹 사이트 개발자가 임의로 지정한 문자열("SALT 값"이라고 한다) 을 덧붙여서 암호화

      => 원본의 패스워드가 길어지므로, 해커는 원본 패스워드 유추가 굉장히 힘들어진다.

      (질문 1) 그래도 Hash의 함수값의 결과 길이는 일정한데, 충돌 때문에 원본 pwd를 알아낼 가능성은 있지 않나?)

      (질문 1-1) 그래서 결국에는 해쉬 함수 값의 길이를 늘리는 것이 본질이지 않을까...? 싶기도 함.

      (질문 1-2) 원본에도 제한이 있나? 그렇지는 않을 거 같지만

      

* 추가로 조사해야 할 사항

  * MD5의 단점 (너무 대략적으로 설명이 되어서, 추가적인 설명이 필요함)



대표적인 Hash 알고리즘

* MD-5
  * 패스워드 암호화에는 쓸 수 없다. (왜냐하면, 해쉬 결과값의 자릿수가 너무 적어서, brute-force 공격으로 뚫릴 수 있다)
  * 보통 SHA-256 알고리즘을 많이 쓰는 추세이다.
* SHA-1
* SHA-128, SHA-256, SHA-384, SHA-512



Hash 알고리즘 적용 예

* 무결성 확보
  * 인증서 검증
  * 디지털 서명
  * 
* 패스워드 단방향 암호화
* 블록체인
  * 데이터를 이루는 덩어리를 Block이며, Block에 대한 무결성을 확보하기 위해 Hash 기술 적용
    * 1번 블록에 대해 Hash 값을 추출
    * 1번 블록의 해쉬값이, 2번 블록의 일부분으로 들어간다
    * 2번 블록의 일부분에 1번 블록의 해쉬값이 들어가며, 2번 블록의 나머지 부분은 데이터로 채워진다
      * 1번 블록의 해쉬값이 있어야만, 2번 블록의 전체를 해쉬함수로 계산 시 1번 블록의 해쉬값과 같아진다.
    * 위 과정을 반복
  * 위 과정에서, 특정 블록의 데이터를 변조시키면, 특정 블록의 해쉬값이 바뀐다.
    * 변조의 정당성을 위해서는, 해쉬를 재계산해야 하는데, 그러러면 앞단의 해쉬값을 변경시켜야 한다고 한다.
      * 근데 그러려면, 앞의 블록의 해쉬값을 다시 계산해서 지금 현재 블록에 다시 넣어야 한다
    * 이러한 블록이 20,000개가 있다면, 위의 과정을 20,000번 반복해야 한다.
  * 따라서, "공개" 데이터의 무결성이 확보가 된다.



## 섹션 2. 암호 기술에 대한 이해

### 매우 쉽게 외우는 대칭키 시스템

대칭키(Symmetric Key)

* 키 1개로 암호화 / 복호화를 모두 수행
* 비대칭키 방식보다 효율적이다.
* 3DES, SEED-128 알고리즘이 대표적인 예



대칭키의 예

* 로직에 XOR이 항상 등장한다고 한다

* 평문 -> 암호문과, 암호문 -> 평문 의 과정이 "동일한 로직" 으로 가능하다

  *  대칭키의 예)

    ```
    (평문)   0100 0001 (0x41)
    (key)   1101 0101
    ----------------   => 각 비트별 XOR 연산
    (암호문) 1001 0100  (0x94)
    ```

  * 키의 길이는 보안과 직결된다

    * 위에서, 평문과 암호문을 안다고 가정 시, brute force 방법으로 XOR연산을 수행해, KEY 값을 알아낼 수 있다. 

      => 해킹!

    * 키 역시 이진수로 된 정보이므로, "안전하게 보관" 하는 것이 핵심이다.



### 외워서 끝내는 비대칭키 시스템

비대칭키(Asymmetric key)

* 한 쌍의 키가 상호 작용
  * 1개의 키는 암호화, 또 다른 1개의 키로 복호화한다.
  * Public Key, Private Key 로 구분
    * Public Key로 암호화하면, Private Key로 복호화해야 한다.
    * 반대로 Private Key로 암호화하면, Public Key로 복호화해야 한다.
  * PKI 기술의 근간을 이룸

* 대표적인 예

  * RSA-2048, ECC알고리즘

* 비대칭키 예시

  * $$
    65^5 \equiv 12 \ \ \ (mod \ 323)  \\
    12^{29} \equiv 65 \ \ \ (mod \ 323)
    $$

  * 위의 수식의 구조는 아래와 같다

    * 평문(65)를, 공개키(5제곱, mod323)을 거쳐서 암호화함. (12 로 암호화)
      * 이후, 암호문(12)를, 비공개키(29제곱, mod323)을 거쳐서 복호화 함(원래 평문인 65로 복호화)

  * 따라서, 아래의 x를 노가다해서 찾는다면, 암호체계는 무너진다.
    $$
    12^X \equiv 65\ \ (mod323)
    $$

    * 엄청 큰 수이므로, 현재는 어려울 수 있으나 양자역학 컴퓨터가 도입된다면 x를 알아낼 수도 있다.





참고

* 코인 역시 블록체인을 활용한 기술이며, 비대칭키 기술로 구현한 예이다.



### 디지털 서명이란?

디지털 서명

* 정의 : Private Key로 해시 결과를 암호화 하는 것

  * 마치 계약서에 도장을 찍어서, 계약이 유효함을 보여주는 것

    * 근데 도장이 사기이면, 안 된다.

      => 정보보안에서는, 위/변조 방지 & 부인 방지 가 존재한다.

  * 기본적으로, 원본 문서를 해시하며, 이 결과를 private key로 암호화해야 한다. (송신 측이)

  * 그리고, 수신 측에서 아래의 과정으로 "디지털 서명"이 진짜 송신인이 수행한 것인지 확인한다

    1') 원본 문서를 해싱한다

    2') 송신측에서 보낸 "암호화된" 해시코드를 공개키로 복호화한다.

    => 1)과 2)가 동일하면, 사실이다. 

* 참고

  * 인터넷 검색 결과, 서명과 문서(메시지)를 동시에 송신한다.

    * 즉, "메시지"를 보냄과 동시에, private key로 "메시지 다이제스트"에 서명한 것을 보낸다.

    * 수신측은, 아래의 2가지 과정을 거친다

      * 받은 메시지를 해시함수를 이용하여 메시지 다이제스트를 만듦
      * 그리고, 수신한 메시지 다이제스트를 public key로 복호화한다

      => 수신측은, 위 2개의 값이 같은지 확인함으로서, "원하는" 송신인이 보냈음을 확인.

  * 출처

    * https://hey-stranger.tistory.com/163

      (좀 더 보고 정리할 것.)

    * http://word.tta.or.kr/dictionary/dictionaryView.do?subject=message%20digest



### 디지털 서명이란?

디지털 서명

* 정의 : Private Key로 해시 결과를 암호화 하는 것

  * 마치 계약서에 도장을 찍어서, 계약이 유효함을 보여주는 것

    * 근데 도장이 사기이면, 안 된다.

      => 정보보안에서는, 위/변조 방지 & 부인 방지 가 존재한다.

  * 기본적으로, 원본 문서를 해시하며, 이 결과를 private key로 암호화해야 한다. (송신 측이)

  * 그리고, 수신 측에서 아래의 과정으로 "디지털 서명"이 진짜 송신인이 수행한 것인지 확인한다

    1') 원본 문서를 해싱한다

    2') 송신측에서 보낸 "암호화된" 해시코드를 공개키로 복호화한다.

    => 1)과 2)가 동일하면, 사실이다. 

* 참고

  * 인터넷 검색 결과, 서명과 문서(메시지)를 동시에 송신한다.

    * 즉, "메시지"를 보냄과 동시에, private key로 "메시지 다이제스트"에 서명한 것을 보낸다.

    * 수신측은, 아래의 2가지 과정을 거친다

      * 받은 메시지를 해시함수를 이용하여 메시지 다이제스트를 만듦
      * 그리고, 수신한 메시지 다이제스트를 public key로 복호화한다

      => 수신측은, 위 2개의 값이 같은지 확인함으로서, "원하는" 송신인이 보냈음을 확인.

  * 출처

    * https://hey-stranger.tistory.com/163

      (좀 더 보고 정리할 것.)

    * http://word.tta.or.kr/dictionary/dictionaryView.do?subject=message%20digest



## 섹션3. PKI 시스템과 인터넷

### 인터넷을 위한 비대칭키 체계

대칭키를 어떻게 내 PC에서 서버까지 안전하게 보낼 수 있을까?

=> 비대칭키로 해결하며, 아래의 과정대로 진행한다

* pc와 server 각각은 키 쌍 생성 (pc의 public key, private key / server의 public key, private key)
* 인터넷에서 public key를 exchange (pc -> server 에게 pc의 public key를, server -> pc 에게 server의 public key를 전송)
* pc는 server의 public key로 암호화하여 server로 보내며, server는 server의 private key로 복호화한다.
  * server가 pc에게 문서를 전송할 때도 마찬가지이다.



아래의 경우, TCP/IP 통신 세션을 "secured session" 이라고 부른다 (tunnel 이라고도 부른다.)

* TCP / IP 통신 세션 확립
* pc와 server 각각 키 쌍을 생성해서, public key를 교환
* 위의 키 쌍을 활용해서, pc와 server 간 비밀 통신을 시행 



생각해 볼 사안

* secured session 을 위한 맨 첫번째 과정(key 쌍 생성 과정)은 시간이 오래 걸리는 일이다.
  * 인텔의 i7같은 성능 좋은 프로세서로 RSA-2048의 키쌍을 생성한다고 가정하자. 그게 비록 1초가 걸리는 일일지라도, 매번 여기저기서 비밀 통신 시도 요청이 들어오면, 서버 입장에서는 난감하다.
* public key를 토대로 private key가 어느정도 유추가 된다
  * 따라서 비대칭키 방식은, 대칭키 방식에 비해 키 길이가 길다. (경우의 수를 엄청 많이 늘리려고)
* 모든 암호에는 유통기한이 존재
  * ** 이 말의 의미가 아직 명확하게 와 닿지 않음.
  * 결국 해당 기한 동안만, 정보를 지키는 개념이다.



### 효율 극대화를 위한 혼합 활용

인터넷 환경에서, 비대칭 키를 되도록이면 안 쓰는 게 좋다.

=> 하지만, 현실상 그렇지 못하므로, 대칭키와 비대칭키를 혼합해서 사용한다.



비대칭키와 대칭키를 혼합하여 아래와 같이 사용한다

1. 서버는 비대칭키 쌍을 생성하며 반대쪽 pc는 대칭키 쌍을 생성한다
2. 우선, pc의 대칭키를 아래와 같은 과정으로 pc에서 서버로 보낼 것이다.
   * 서버의 공개키를 pc로 보낸다
   * 서버의 공개키를 pc의 대칭키를 암호화한 후, 서버로 보낸다
   * 서버의 개인키로 pc의 대칭키를 복호화
3. 이제, pc에서 서버로 보내고자 하는 평문을 "pc의 대칭키"로 암호화한 후, 서버로 전송
4. 서버에서, "앞 과정에서 받은" pc의 대칭키로 3번의 암호문을 복호화



이제, 서버에 여러대의 pc가 달려있다고 가정하자.

* 기존에 서버랑 secured session을 맺었던 pc는, 대칭키를 활용해서 통신하고 있다

  * 이 pc는, 서버와 연결된 pc와 secured session을 맺을 때, 또다른 대칭키를 생성하여 활용한다

    => 보안성이 뛰어나진다.



참고

* PC가 만든 키를, "Session Key" 라고도 부름.
  * 서버에 연결된 pc마다, Session key를 다르게 부여할 수 있다.
  * 보안성이 뛰어나질 수 있다.



### 비대칭키 체계의 문제점

위의 혼합방식에서는 1가지 문제점이 있다

=> pc가 받은 server의 공개키가 "정말 server가 보낸 진짜 공개키" 인지 진위여부를 판별할 수 있는 체계가 없다.

=> 따라서, "중간자 공격" (MITM) 이 가능하며 이는 아래와 같다.



중간자 공격(MITM)

* PC와 server의 네트워크 경로 사이에 해커가 존재

* server가 pc로 server의 public 키를 보낼 떄, 해커가 가로채고, 해커의 public 키를 pc로 보냄
* pc는 pc의 대칭키를 "해커의 public 키" 로 암호화
* pc는 위의 암호화된 pc의 대칭키(=session key)를 서버로 보낸다(실제로는 해커로 간다)
  * 해커는 위의 pc의 대칭키를 가로채서 복호화한다.
* pc는 그리고, 앞서 가로챈 "server의 public 키"로 session key를 암호화함
  * 이 암호화한 session key를 server로 보낸다
* 이 때, pc와 server는 정상적으로 통신되는 것처럼 보이지만, 해커는 무슨 내용을 통신하는지 알게 된다.



따라서, 원격지에서 정보가 오면, 이게 진짜 원격지에서 온 것이 맞는지 "검증"해야 한다.

=> "인증 체계" 등장.



### 공개키 신뢰를 위한 검증체계

결국, 서버에서 보낸 공개키를 어떻게 신뢰하게끔 체계를 갖추는지가 핵심이다.

=> 서버에서는, 공개키 대신 (믿을 수 있는) 인증서를 pc로 보낸다

=> pc에서는, 해당 인증서의 정보를 근거로, PC의 디스크에 저장된 CA의 public key를 활용하여 "진짜 서버에서 보냈는지" 검증한다

=> 이제, 서버에서 보낸 public key를 신뢰할 수 있으므로, pc는 서버의 public key(이제 진짜가 검증됨!)를 활용하여 pc의 대칭키를 암호화하여 server로 전송 



자세한 과정은 아래와 같다.

* Web Server는 직접 public key, private key 쌍을 생성하는 대신, RA에 구매 요청을 한다
* RA는 CA에 Web Server의 인증서를 생성 요청한다.
* CA는 private key와, "public key가 담긴 인증서"를 RA에 제공한다
  * 인증서에는, 크게 아래의 3가지 요소로 이루어져 있다.
    * user Information (유효기간 등)
    * public key
    * "위 2가지의 요소를 hash알고리즘을 적용한 hash 값" 을 CA의 private key로 암호화한 값
      * 추후, pc에서 무결성 check에 활용된다.
* RA는 private key와 "public key가 담긴 인증서"를 웹 서버 담당자에게 제공
* Web Server 담당자는 위의 인증서와 private key를 웹 서버에 저장
  * 이제 PC에서는, Server로 HTTPS 요청이 들어온다
  * ★ Server는 Server의 공개키를 보내지 않고, "인증서"를 보낸다
    * 해당 인증서에는 Server의 공개키가 포함되어 있다는 점 다시 상기할 것.
  * PC는 아래의 과정을 거쳐 "수신한 인증서"가 믿어도 되는 인증서인지 검증한다
    * 디스크에 저장되어 있는 CA의 공개키를 활용하여 암호화된 HASH 값을 복호화함.
      * CA의 공개키는,PC에 보안업데이트 때마다 저장된다. (WINDOWS OS 가정 시,  MS가 제휴된 CA사로부터 받은 공개키이다.)
    * 그리고, 인증서의 나머지 요소를 HASH 알고리즘을 적용하여 또 다른 HASH 값 도출
    * 위 2가지 값이 일치하면, PC는 "믿어도 되는 인증서" 라고 검증함
* 이제 PC는 웹 서버의 public key를(이제 진짜 믿어도 된다!) 활용하여 session key를 암호화한다
  * 암호화한 session key를 서버로 전달. 서버는 이를 server의 private key 로 복호화.



Digital Certificate의 요소는 따라서 아래와 같은 구조라고 말할 수 있다.

* User Information
* public key
* 위 2가지 요소를 hash알고리즘 적용하여 도출한 hash 값을, CA의 private key로 암호화 적용한 결과물



PKI 인증체계는 위와 같으며 추가적으로 알아두어야 할 사항은 아래와 같다

* RA 상위 기관이 CA이며, 이것이 끝이 아니라 더 상위 기관인 PAA, PCA 가 있다.



참고

* MS가 보안 업데이트 할 때, 기관 인증서(=CA의 Public Key) 를 설치(UPDATE) 한다.

  => PC는 이 기관 인증서로 "받은 인증서" 를 확인한다.





### 웹 서비스와 공인인증서

웹 서버 구조 분석 시, SSL 인증서를 분석하면 된다.

=> SSL 인증서가 어디에 설치되는지를 분석하면 된다.





은행에서 공인인증서를 발급받을 때 순서

* 유저 A는 우리은행에 공인인증서 발급을 요청

  * 우리은행은 CA에게 유저 A의 공인인증서 등록 요청

    * 따라서, 이 때 우리은행은 RA 역할을 수행한다고 말할 수 있다.

  * 우리은행은 (유저 A의 공인인증서 + private key)를 CA로부터 받아서, 유저 A에게 전달

    * (내 생각) 이 때 private key는 유저가 입력한 패스워드로 암호화된다.

      =>  내 생각이라고 명명한 이유는, private key를 암호화하지 않고 주면 뚫리기 때문??

* 이제, 유저 A는 어떠한 작업을 수행 후, 인터넷 뱅킹 서버로 유저 A의 공인인증서를 보낸다

  * 은행은 CA로부터의 인증을 거쳐, 해당 공인인증서를 신뢰하게 된다. (유저 A임을 신뢰한다.)

* 이제 인터넷 뱅킹 서버는 "A의 (신뢰할 수 있는) 공개키" 를 토대로 대칭키를 암호화하여, 유저 A에게 보낸다.

  * 유저 A는 패스워드를 입력하며, 이 패스워드로 암호화된 개인키를 우선 복호화를 시도함

    => 사전에 지정한 패스워드와 일치한다면, 개인키는 복호화된다.

  * 복호화된 유저 A의 개인키로, "유저 A의 개인키로 암호화한 대칭키" 를 복호화한다.

* 이제 대칭키를 유저 A와 인터넷 뱅킹 서버가 안전하게 공유하였기 때문에, 해당 대칭키로 데이터를 암호화/복호화하여 송/수신한다.






참고

* 공인인증서는 공개키만 가지고 있는 구조도 있으며, 공개키와 개인키가 혼재된 구조도 있다.

  * 출처 : https://perfectacle.github.io/2020/01/24/korean-certification/

* 공인인증서의 개인키가 사용되는 곳

  * 기본적으로 공인인증서의 개인키는 암호화되어 있으며, 이는 "유저의 패스워드 입력"에 의해 복호화된다.

    * 이 복호화된 개인키를 토대로, "인터넷 뱅킹 서버로부터" 받은 "암호화된 대칭키 파일"을 복호화하여 대칭키 파일을 획득한다

      => 물론, 인터넷 뱅킹 서버는, "유저의 공개키로" 대칭키 파일을 암호화한다.

  * 출처 : https://brunch.co.kr/@ka3211/13 ★

* 공인인증서는 인증이 목적!

  => 말 그대로, 암호화 통신이 목적이 아닌, "사용자" 가 진짜 사용자인지 인증하는 작업

