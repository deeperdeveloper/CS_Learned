# 외워서 끝내는 SSL과 암호기술 이론



## 섹션1. 기초이론

### 이름 궁합과 Checksum

* CheckSum(검사합)

  * 데이터가 변조되었는지 검사

  * 이 값은 자릿수를 유지한다. (= 즉, 최소한의 공간(?)만 차지한다.)

    => 이는 데이터를 활용해서 계산 시, 범위를 넘는 자리는 버림으로서 구현한다.

  * 보안성이 없으며 기밀성이 없다. 무결성도 없다

    * 보안성이 없으므로, 누군가가 원본의 CheckSum 값을 조작해서 보낼 수도 있으며, 수신측은 이를 인지하지 못하게 될 수 있다.

      => 따라서, Hash를 활용해서 CheckSum 값에 대한 보안성을 높인다.

  * 원본 데이터와 복사본 데이터가 일치하는지 확인하는데 쓰임

    * 원본 데이터를 보낼 때, CheckSum값을 별도로 보내며, 수신측에서도 복사본 데이터를 토대로 CheckSum값을 계산함

      => 2개의 CheckSum 값이 일치하면, 제대로 데이터가 송신되었다고 볼 수 있다.

  * 검사합 값을 토대로, 원본 문자열(데이터)을 복원하는 것은 불가능하다.

    * 오직, 원본 문자열 -> 검사합 값 으로 진행하는 단방향 로직만 가능
    * 마찬가지로, 위의 로직 진행 과정에서 원본 문자열의 각 문자가 변환된 어떠한 숫자(데이터)를 토대로 다시 복원시키는 것도 안 된다.



### Hash에 대해 외울 것들

Hash 함수 특징

* 단방향성

  * 즉, f(x) → y 이고, y값을 토대로 x를 추리하지는 못한다.

* 입력 값의 크기와 상관없이 결과 값의 길이(크기)는 항상 일정

  * 예를 들면, 해쉬 함수의 결과값으로 mod 연산값이라고 하면, 크기가 항상 일정하다.

* 데이터 무결성 확보와 관련해서 IT 기술 전반에서 사용된다.

  * 즉, 데이터가 절대 위조되지 않았다는 것을 증명하는 데에 사용됨

    => 따라서, CheckSum이 하는 일을 Hash가 대체하기도 한다. (물론 좀 복잡하긴 하다.)

* 좋은 해쉬 함수의 특징

  * 원본이 달라지면 결과값이 되도록 달라져야 한다.
    * 예) x % y -> 결과값일 때, x가 달라지면 결과값도 되도록이면 달라지게끔 해야 한다. 

* 홈페이지에 비밀번호를 저장할 때, 반드시 평문이 아닌 "암호화"하여 DB에 저장하여야 한다.

  * 이 과정에서, Hash 함수가 쓰인다.
  * 단방향 암호화이므로, 홈페이지 관리자도 PWD를 알아낼 수 없다.

* Hash 함수의 문제점 및 보완책

  * 단순히 비밀번호를 Hash 함수를 적용하여 저장하면, 해커가 DB를 해킹했을 때 역추적이 될 수 있다

    * 그래서, 사용자가 입력한 비밀번호에, 웹 사이트 개발자가 임의로 지정한 문자열("SALT 값"이라고 한다) 을 덧붙여서 암호화

      => 원본의 패스워드가 길어지므로, 해커는 원본 패스워드 유추가 굉장히 힘들어진다.

      (질문 1) 그래도 Hash의 함수값의 결과 길이는 일정한데, 충돌 때문에 원본 pwd를 알아낼 가능성은 있지 않나?)

      (질문 1-1) 그래서 결국에는 해쉬 함수 값의 길이를 늘리는 것이 본질이지 않을까...? 싶기도 함.

      (질문 1-2) 원본에도 제한이 있나? 그렇지는 않을 거 같지만

      

* 추가로 조사해야 할 사항

  * MD5의 단점 (너무 대략적으로 설명이 되어서, 추가적인 설명이 필요함)



대표적인 Hash 알고리즘

* MD-5
  * 패스워드 암호화에는 쓸 수 없다. (왜냐하면, 해쉬 결과값의 자릿수가 너무 적어서, brute-force 공격으로 뚫릴 수 있다)
  * 보통 SHA-256 알고리즘을 많이 쓰는 추세이다.
* SHA-1
* SHA-128, SHA-256, SHA-384, SHA-512



Hash 알고리즘 적용 예

* 무결성 확보
  * 인증서 검증
  * 디지털 서명
  * 
* 패스워드 단방향 암호화
* 블록체인
  * 데이터를 이루는 덩어리를 Block이며, Block에 대한 무결성을 확보하기 위해 Hash 기술 적용
    * 1번 블록에 대해 Hash 값을 추출
    * 1번 블록의 해쉬값이, 2번 블록의 일부분으로 들어간다
    * 2번 블록의 일부분에 1번 블록의 해쉬값이 들어가며, 2번 블록의 나머지 부분은 데이터로 채워진다
      * 1번 블록의 해쉬값이 있어야만, 2번 블록의 전체를 해쉬함수로 계산 시 1번 블록의 해쉬값과 같아진다.
    * 위 과정을 반복
  * 위 과정에서, 특정 블록의 데이터를 변조시키면, 특정 블록의 해쉬값이 바뀐다.
    * 변조의 정당성을 위해서는, 해쉬를 재계산해야 하는데, 그러러면 앞단의 해쉬값을 변경시켜야 한다고 한다.
      * 근데 그러려면, 앞의 블록의 해쉬값을 다시 계산해서 지금 현재 블록에 다시 넣어야 한다
    * 이러한 블록이 20,000개가 있다면, 위의 과정을 20,000번 반복해야 한다.
  * 따라서, "공개" 데이터의 무결성이 확보가 된다.



## 섹션 2. 암호 기술에 대한 이해

### 매우 쉽게 외우는 대칭키 시스템

대칭키(Symmetric Key)

* 키 1개로 암호화 / 복호화를 모두 수행
* 비대칭키 방식보다 효율적이다.
* 3DES, SEED-128 알고리즘이 대표적인 예



대칭키의 예

* 로직에 XOR이 항상 등장한다고 한다

* 평문 -> 암호문과, 암호문 -> 평문 의 과정이 "동일한 로직" 으로 가능하다

  *  대칭키의 예)

    ```
    (평문)   0100 0001 (0x41)
    (key)   1101 0101
    ----------------   => 각 비트별 XOR 연산
    (암호문) 1001 0100  (0x94)
    ```

  * 키의 길이는 보안과 직결된다

    * 위에서, 평문과 암호문을 안다고 가정 시, brute force 방법으로 XOR연산을 수행해, KEY 값을 알아낼 수 있다. 

      => 해킹!

    * 키 역시 이진수로 된 정보이므로, "안전하게 보관" 하는 것이 핵심이다.



### 외워서 끝내는 비대칭키 시스템

비대칭키(Asymmetric key)

* 한 쌍의 키가 상호 작용
  * 1개의 키는 암호화, 또 다른 1개의 키로 복호화한다.
  * Public Key, Private Key 로 구분
    * Public Key로 암호화하면, Private Key로 복호화해야 한다.
    * 반대로 Private Key로 암호화하면, Public Key로 복호화해야 한다.
  * PKI 기술의 근간을 이룸

* 대표적인 예

  * RSA-2048, ECC알고리즘

* 비대칭키 예시

  * $$
    65^5 \equiv 12 \ \ \ (mod \ 323)  \\
    12^{29} \equiv 65 \ \ \ (mod \ 323)
    $$

  * 위의 수식의 구조는 아래와 같다

    * 평문(65)를, 공개키(5제곱, mod323)을 거쳐서 암호화함. (12 로 암호화)
      * 이후, 암호문(12)를, 비공개키(29제곱, mod323)을 거쳐서 복호화 함(원래 평문인 65로 복호화)

  * 따라서, 아래의 x를 노가다해서 찾는다면, 암호체계는 무너진다.
    $$
    12^X \equiv 65\ \ (mod323)
    $$

    * 엄청 큰 수이므로, 현재는 어려울 수 있으나 양자역학 컴퓨터가 도입된다면 x를 알아낼 수도 있다.





참고

* 코인 역시 블록체인을 활용한 기술이며, 비대칭키 기술로 구현한 예이다.

